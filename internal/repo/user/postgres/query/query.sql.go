// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package query

import (
	"context"
)

const upsertUser = `-- name: UpsertUser :exec
INSERT INTO users (id, has_registered, is_supplier, first_name, last_name, surname, telephone, whatsapp, telegram)
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
)
ON CONFLICT (id) DO UPDATE SET
    has_registered = EXCLUDED.has_registered,
    is_supplier    = EXCLUDED.is_supplier,
    first_name     = EXCLUDED.first_name,
    last_name      = EXCLUDED.last_name,
    surname        = EXCLUDED.surname,
    telephone      = EXCLUDED.telephone,
    whatsapp       = EXCLUDED.whatsapp,
    telegram       = EXCLUDED.telegram,
    updated_at     = EXCLUDED.updated_at
`

type UpsertUserParams struct {
	ID            int64
	HasRegistered bool
	IsSupplier    bool
	FirstName     string
	LastName      string
	Surname       string
	Telephone     string
	Whatsapp      string
	Telegram      string
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.Exec(ctx, upsertUser,
		arg.ID,
		arg.HasRegistered,
		arg.IsSupplier,
		arg.FirstName,
		arg.LastName,
		arg.Surname,
		arg.Telephone,
		arg.Whatsapp,
		arg.Telegram,
	)
	return err
}

const user = `-- name: User :one
SELECT id, has_registered, is_supplier, first_name, last_name, surname, telephone, whatsapp, telegram, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) User(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, user, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.HasRegistered,
		&i.IsSupplier,
		&i.FirstName,
		&i.LastName,
		&i.Surname,
		&i.Telephone,
		&i.Whatsapp,
		&i.Telegram,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
